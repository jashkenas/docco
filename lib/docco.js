// Generated by CoffeeScript 1.4.0
(function() {
  var commander, defaults, document, ensureDirectory, exec, ext, fs, generateDocumentation, generateDocumentationFromFile, generateDocumentationFromStdin, generateHtml, getDestination, getDir, getLanguage, getResource, getTitle, highlight, highlightEnd, highlightStart, htmlEscape, key, l, languages, parse, path, resolveSource, run, showdown, spawn, template, value, version, _ref, _ref1,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  generateDocumentationFromStdin = function(config, callback) {
    process.stdin.resume();
    process.stdin.setEncoding('utf8');
    process.stdin.on('error', function(error) {
      throw error;
    });
    return process.stdin.on('data', function(buffer) {
      var dest, language, title;
      process.stdin.pause();
      language = languages['.' + (config.language.length ? config.language : "coffee")];
      title = getTitle(config.output);
      dest = getDestination(config.output, title);
      return generateDocumentation(language, title, "stdin", dest, buffer, config, callback);
    });
  };

  generateDocumentationFromFile = function(source, config, callback) {
    return fs.readFile(source, function(error, buffer) {
      var dest, language, title;
      if (error) {
        throw error;
      }
      language = config.language && languages['.' + config.language] ? languages['.' + config.language] : getLanguage(source);
      title = path.basename(source);
      dest = getDestination(config.output, source);
      return generateDocumentation(language, title, source, dest, buffer, config, callback);
    });
  };

  generateDocumentation = function(language, title, source, dest, buffer, config, callback) {
    var code, sections;
    code = buffer.toString();
    sections = parse(language, code);
    return highlight(language, sections, function() {
      generateHtml(title, source, dest, sections, config);
      return callback();
    });
  };

  parse = function(language, code) {
    var codeText, docsText, hasCode, line, lines, save, sections, _i, _len;
    lines = code.split('\n');
    sections = [];
    hasCode = docsText = codeText = '';
    save = function(docsText, codeText) {
      return sections.push({
        docsText: docsText,
        codeText: codeText
      });
    };
    for (_i = 0, _len = lines.length; _i < _len; _i++) {
      line = lines[_i];
      if (line.match(language.commentMatcher) && !line.match(language.commentFilter)) {
        if (hasCode) {
          save(docsText, codeText);
          hasCode = docsText = codeText = '';
        }
        docsText += line.replace(language.commentMatcher, '') + '\n';
      } else {
        hasCode = true;
        codeText += line + '\n';
      }
    }
    save(docsText, codeText);
    return sections;
  };

  highlight = function(language, sections, callback) {
    var code, docs, output, pygments, section;
    pygments = spawn('pygmentize', ['-l', language.name, '-f', 'html', '-O', 'encoding=utf-8,tabsize=2']);
    output = '';
    code = ((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = sections.length; _i < _len; _i++) {
        section = sections[_i];
        _results.push(section.codeText);
      }
      return _results;
    })()).join(language.codeSplitText);
    docs = ((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = sections.length; _i < _len; _i++) {
        section = sections[_i];
        _results.push(section.docsText);
      }
      return _results;
    })()).join(language.docsSplitText);
    pygments.stderr.on('data', function() {});
    pygments.stdin.on('error', function() {});
    pygments.stdout.on('data', function(result) {
      if (result) {
        return output += result;
      }
    });
    pygments.on('exit', function() {
      var codeFragments, docsFragments, i, _i, _len;
      output = output.replace(highlightStart, '').replace(highlightEnd, '');
      if (output === '') {
        codeFragments = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = sections.length; _i < _len; _i++) {
            section = sections[_i];
            _results.push(htmlEscape(section.codeText));
          }
          return _results;
        })();
      } else {
        codeFragments = output.split(language.codeSplitHtml);
      }
      docsFragments = showdown.makeHtml(docs).split(language.docsSplitHtml);
      for (i = _i = 0, _len = sections.length; _i < _len; i = ++_i) {
        section = sections[i];
        section.codeHtml = highlightStart + codeFragments[i] + highlightEnd;
        section.docsHtml = docsFragments[i];
      }
      return callback();
    });
    if (pygments.stdin.writable) {
      pygments.stdin.write(code);
      return pygments.stdin.end();
    }
  };

  htmlEscape = function(string) {
    return string.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#x27;').replace(/\//g, '&#x2F;');
  };

  generateHtml = function(title, source, dest, sections, config) {
    var html;
    html = config.doccoTemplate({
      title: title,
      sections: sections,
      sources: config.sources,
      path: path,
      destination: getDestination,
      css: path.basename(config.css)
    });
    if (config.output === 'stdout') {
      return console.log(html);
    } else if (config.output === 'stderr') {
      return console.error(html);
    } else {
      console.log("docco: " + source + " -> " + dest);
      return fs.writeFileSync(dest, html);
    }
  };

  fs = require('fs');

  path = require('path');

  showdown = require('./../vendor/showdown').Showdown;

  _ref = require('child_process'), spawn = _ref.spawn, exec = _ref.exec;

  commander = require('commander');

  getResource = function(name) {
    var fullPath;
    fullPath = path.join(__dirname, '..', 'resources', name);
    return fs.readFileSync(fullPath).toString();
  };

  languages = JSON.parse(getResource('languages.json'));

  for (ext in languages) {
    l = languages[ext];
    l.commentMatcher = RegExp("^\\s*" + l.symbol + "\\s?");
    l.commentFilter = /(^#![/]|^\s*#\{)/;
    l.codeSplitText = "\n" + l.symbol + "DIVIDER\n";
    l.codeSplitHtml = RegExp("\\n*<span\\sclass=\"c1?\">" + l.symbol + "DIVIDER<\\/span>\\n*");
    l.docsSplitText = "\n#" + l.name + "DOCDIVIDER\n";
    l.docsSplitHtml = RegExp("<h1>" + l.name + "DOCDIVIDER</h1>");
  }

  getLanguage = function(source) {
    return languages[path.extname(source)];
  };

  ensureDirectory = function(dir, cb, made) {
    var mode;
    if (made == null) {
      made = null;
    }
    mode = parseInt('0777', 8);
    return fs.mkdir(dir, mode, function(er) {
      if (!er) {
        return cb(null, made || dir);
      }
      if (er.code === 'ENOENT') {
        return ensureDirectory(path.dirname(dir), function(er, made) {
          if (er) {
            return cb(er, made);
          } else {
            return ensureDirectory(dir, cb, made);
          }
        });
      }
      return cb(er, made);
    });
  };

  getDestination = function(output, filepath) {
    console.log(path.join(getDir(output), path.basename(filepath, path.extname(filepath)) + '.html'));
    return path.join(getDir(output), path.basename(filepath, path.extname(filepath)) + '.html');
  };

  getTitle = function(output) {
    if (path.extname(output)) {
      return path.basename(output);
    } else {
      return "stdin";
    }
  };

  getDir = function(output) {
    if (path.extname(output)) {
      return path.dirname(output);
    } else {
      return output;
    }
  };

  template = function(str) {
    return new Function('obj', 'var p=[],print=function(){p.push.apply(p,arguments);};' + 'with(obj){p.push(\'' + str.replace(/[\r\t\n]/g, " ").replace(/'(?=[^<]*%>)/g, "\t").split("'").join("\\'").split("\t").join("'").replace(/<%=(.+?)%>/g, "',$1,'").split('<%').join("');").split('%>').join("p.push('") + "');}return p.join('');");
  };

  highlightStart = '<div class="highlight"><pre>';

  highlightEnd = '</pre></div>';

  version = JSON.parse(fs.readFileSync("" + __dirname + "/../package.json")).version;

  defaults = {
    template: "" + __dirname + "/../resources/docco.jst",
    css: "" + __dirname + "/../resources/docco.css",
    output: "docs/",
    language: ""
  };

  run = function(args) {
    if (args == null) {
      args = process.argv;
    }
    commander.version(version).usage("[options] <filePattern ...>").option("-c, --css [file]", "use a custom css file", defaults.css).option("-o, --output [stdout|stderr|path]", "use a custom output to stdout, stderror or a path", defaults.output).option("-t, --template [file]", "use a custom .jst template", defaults.template).option("-l, --language [language]", "use a custom language, required if reading from the stdin", defaults.language).parse(args).name = "docco";
    if (commander.args.length) {
      return document(commander.args.slice(), commander);
    } else {
      return console.log(commander.helpInformation());
    }
  };

  document = function(sources, options, callback) {
    var config, doccoStyles, key, m, resolved, src, value, _i, _j, _len, _len1;
    if (options == null) {
      options = {};
    }
    if (callback == null) {
      callback = null;
    }
    config = {};
    for (key in defaults) {
      value = defaults[key];
      config[key] = defaults[key];
    }
    if (key in defaults) {
      for (key in options) {
        value = options[key];
        config[key] = value;
      }
    }
    config.doccoTemplate = template(fs.readFileSync(config.template).toString());
    doccoStyles = fs.readFileSync(config.css).toString();
    if (sources.length === 1 && sources[0] === 'stdin') {
      config.sources = sources;
      return ensureDirectory(getDir(config.output), function() {
        if (config.output !== 'stdout' && config.output !== 'stderr') {
          fs.writeFileSync(path.join(getDir(config.output), path.basename(config.css)), doccoStyles);
        }
        return generateDocumentationFromStdin(config, function() {
          if (callback != null) {
            return callback();
          }
        });
      });
    } else {
      resolved = [];
      for (_i = 0, _len = sources.length; _i < _len; _i++) {
        src = sources[_i];
        resolved = resolved.concat(resolveSource(src));
      }
      config.sources = resolved.filter(function(source) {
        return getLanguage(source);
      }).sort();
      for (_j = 0, _len1 = resolved.length; _j < _len1; _j++) {
        m = resolved[_j];
        if (__indexOf.call(config.sources, m) < 0) {
          console.log("docco: skipped unknown type (" + m + ")");
        }
      }
      return ensureDirectory(getDir(config.output), function() {
        var files, nextFile;
        fs.writeFileSync(path.join(getDir(config.output), path.basename(config.css)), doccoStyles);
        files = config.sources.slice();
        nextFile = function() {
          if ((callback != null) && !files.length) {
            callback();
          }
          if (files.length) {
            return generateDocumentationFromFile(files.shift(), config, nextFile);
          }
        };
        return nextFile();
      });
    }
  };

  resolveSource = function(source) {
    var file, file_path, files, regex, regex_str;
    if (!source.match(/([\*\?])/)) {
      return source;
    }
    regex_str = path.basename(source).replace(/\./g, "\\$&").replace(/\*/, ".*").replace(/\?/, ".");
    regex = new RegExp('^(' + regex_str + ')$');
    file_path = path.dirname(source);
    files = fs.readdirSync(file_path);
    return (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = files.length; _i < _len; _i++) {
        file = files[_i];
        if (file.match(regex)) {
          _results.push(path.join(file_path, file));
        }
      }
      return _results;
    })();
  };

  _ref1 = {
    run: run,
    document: document,
    parse: parse,
    resolveSource: resolveSource,
    version: version,
    defaults: defaults,
    languages: languages,
    ensureDirectory: ensureDirectory
  };
  for (key in _ref1) {
    value = _ref1[key];
    exports[key] = value;
  }

}).call(this);
